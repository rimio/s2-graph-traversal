#!/bin/python

#
# Copyright (c) 2021 Vasile Vilvoiu <vasi@vilvoiu.ro>
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the MIT license. See LICENSE for details.
#

import sys
import argparse
import re
import json
import s2util


class ProjectRuleConcatAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        current = getattr(namespace, self.dest)
        new = {'action': 'project', 'expression': values}
        if current is None:
            current = [new]
        else:
            current.append(new)
        setattr(namespace, self.dest, current)


class RejectRuleConcatAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        current = getattr(namespace, self.dest)
        new = {'action': 'reject', 'expression': values}
        if current is None:
            current = [new]
        else:
            current.append(new)
        setattr(namespace, self.dest, current)


def project(object, rules):
    nobject = {}
    for key in object.keys():
        project = True
        for rule in rules:
            kpass = re.search(rule['compiled'], key)
            if kpass:
                if rule['action'] == 'reject':
                    project = False
                elif rule['action'] == 'project':
                    project = True
                else:
                    raise Exception('unknown action {}'.format(rule['action']))
        if project:
            nobject[key] = object[key]
    return nobject


class ProjectionIterator(s2util.ObjectIterator):
    def __init__(self, archive_urls, rules):
        super().__init__(archive_urls)
        self.rules = rules

    def process(self, obj, archive_url, object_no):
        pobj = project(obj, self.rules)
        jpobj = json.dumps(pobj)
        print(jpobj)


def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Filter-projector for semantic scholar entries')
    parser.add_argument('corpus', type=str, help='corpus directory URL (where manifest file is found)')
    parser.add_argument('--archive-regex', type=str, help='regex to match against archive filenames before processing',
                        default='s2[-]corpus[-][1-9]?[0-9]{3}[.]gz')
    parser.add_argument('-p', '--project', action=ProjectRuleConcatAction,
                        help='field projection rule (may be repeated)', dest='prules')
    parser.add_argument('-r', '--reject', action=RejectRuleConcatAction,
                        help='field rejection rule (may be repeated)', dest='prules')
    args = parser.parse_args()

    # Compile projection regexp list
    projection_rules = []
    if args.prules is not None:
        for r in args.prules:
            rule = r.copy()
            rule['compiled'] = re.compile(rule['expression'])
            projection_rules.append(rule)

    # Load archives of interest
    archive_urls = s2util.fetch_archive_urls(args.corpus, args.archive_regex)

    # Filter and print to stdout
    ProjectionIterator(archive_urls, projection_rules).iterate()


if __name__ == '__main__':
    main()
